<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EmojiMania Splitter</title>
    <meta name="description" content="Split an EmojiMania sprite sheet into individual PNG and SVG icons (with optional scaling) directly in the browser.">

    <link rel="canonical" href="https://adamdburton.github.io/emojimania-splitter/">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://adamdburton.github.io/emojimania-splitter/">
    <meta property="og:title" content="EmojiMania Splitter">
    <meta property="og:description" content="Split an EmojiMania sprite sheet into individual PNG and SVG icons (with optional scaling) directly in the browser.">
    <meta property="og:image" content="https://adamdburton.github.io/emojimania-splitter/preview.png">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="EmojiMania Splitter">
    <meta name="twitter:description" content="Split an EmojiMania sprite sheet into individual PNG and SVG icons (with optional scaling) directly in the browser.">
    <meta name="twitter:image" content="https://adamdburton.github.io/emojimania-splitter/preview.png">

    <meta name="theme-color" content="#111827">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        .canvas-container {
            overflow: auto;
            max-height: 70vh;
            border: 2px solid #374151;
            background-color: #1f2937;
            position: relative;
        }
        canvas {
            image-rendering: pixelated;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen font-sans">
    <div class=" p-6">
        <h1 class="text-3xl font-bold mb-6 text-blue-400">EmojiMania Icon Splitter</h1>
        
        <div class="grid grid-cols-1 lg:grid-cols-5 gap-6">
            <!-- Sidebar Controls -->
            <div class="bg-gray-800 p-4 rounded-lg shadow-lg h-fit space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-1">Source Image</label>
                    <input type="file" id="fileInput" accept="image/*" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700"/>
                </div>

                <div class="border-t border-gray-700 pt-4 space-y-3">
                    <h2 class="text-lg font-semibold text-gray-200">Grid Settings</h2>
                    
                    <div class="grid grid-cols-2 gap-2">
                        <div>
                            <label class="block text-xs uppercase text-gray-500">Left Offset</label>
                            <input type="number" id="offsetX" value="12" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 focus:outline-none focus:border-blue-500">
                        </div>
                        <div>
                            <label class="block text-xs uppercase text-gray-500">Top Offset</label>
                            <input type="number" id="offsetY" value="34" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 focus:outline-none focus:border-blue-500">
                        </div>
                    </div>

                    <div class="grid grid-cols-2 gap-2">
                        <div>
                            <label class="block text-xs uppercase text-gray-500">Icon Width</label>
                            <input type="number" id="iconWidth" value="9" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 focus:outline-none focus:border-blue-500">
                        </div>
                        <div>
                            <label class="block text-xs uppercase text-gray-500">Icon Height</label>
                            <input type="number" id="iconHeight" value="9" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 focus:outline-none focus:border-blue-500">
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-2 gap-2">
                         <div>
                            <label class="block text-xs uppercase text-gray-500">Gap X</label>
                            <input type="number" id="gapX" value="2" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 focus:outline-none focus:border-blue-500">
                        </div>
                        <div>
                            <label class="block text-xs uppercase text-gray-500">Gap Y</label>
                            <input type="number" id="gapY" value="2" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 focus:outline-none focus:border-blue-500">
                        </div>
                    </div>

                    <div>
                        <label class="block text-xs uppercase text-gray-500">Group Count</label>
                        <input type="number" id="groupCount" value="7" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 focus:outline-none focus:border-blue-500">
                    </div>

                    <div>
                        <label class="block text-xs uppercase text-gray-500">Group Names</label>
                        <input type="text" id="groupNames" value="people, nature, food, activity, travel, objects, symbols" placeholder="Animals, Faces, Food" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 focus:outline-none focus:border-blue-500">
                        <p class="text-[10px] text-gray-500 mt-1">Comma-separated (spaces optional). Used for export names.</p>
                    </div>

                     <div>
                        <label class="block text-xs uppercase text-gray-500">Group Offset X</label>
                        <input type="number" id="groupOffsetX" value="99" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 focus:outline-none focus:border-blue-500">
                        <p class="text-[10px] text-gray-500 mt-1">Horizontal distance between start of groups</p>
                    </div>
                    
                    <div>
                         <label class="block text-xs uppercase text-gray-500">Group Cols</label>
                         <input type="number" id="colsPerGroup" value="8" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 focus:outline-none focus:border-blue-500">
                    </div>
                    <div>
                        <label class="flex items-center justify-between text-xs uppercase text-gray-500">
                            <span>Export Scale</span>
                            <span id="exportScaleValue" class="text-gray-400">1</span>
                        </label>
                        <input type="range" id="exportScale" value="1" min="1" max="10" step="1" class="w-full accent-blue-500">
                    </div>

                    <div>
                        <label class="flex items-center justify-between text-xs uppercase text-gray-500">
                            <span>Preview Zoom</span>
                            <span id="previewZoomValue" class="text-gray-400">3</span>
                        </label>
                        <input type="range" id="previewZoom" value="3" min="1" max="10" step="0.25" class="w-full accent-blue-500">
                        <p class="text-[10px] text-gray-500 mt-1">Scales the preview only (exports unchanged).</p>
                    </div>

                    <div class="pt-1">
                        <label class="flex items-center gap-2 text-xs uppercase text-gray-500 select-none">
                            <input type="checkbox" id="showOverlay" class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-blue-600 focus:ring-blue-500">
                            <span>Show Overlay</span>
                        </label>
                        <p class="text-[10px] text-gray-500 mt-1">Toggles the grid overlay visibility.</p>
                    </div>
                </div>

                <div class="border-t border-gray-700 pt-4">
                    <button id="processBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition disabled:opacity-50 disabled:cursor-not-allowed">
                        Split & Download ZIP
                    </button>
                </div>
            </div>

            <!-- Main Preview Area -->
            <div class="col-span-1 lg:col-span-3">
                <div class="canvas-container rounded shadow-lg relative" id="canvasContainer">
                     <canvas id="srcCanvas" class="block"></canvas>
                     <canvas id="overlayCanvas" class="absolute top-0 left-0 cursor-pointer"></canvas>
                </div>
            </div>

            <div class="col-span-1 lg:col-span-1">
                <div class="bg-gray-800 p-4 rounded-lg shadow-lg space-y-2" id="singleExportPanel" style="display:none;">
                    <h2 class="text-lg font-semibold text-gray-200">Single Icon Export</h2>

                    <div class="pt-2">
                            <label class="block text-xs uppercase text-gray-500 mb-1">Preview (16×)</label>
                        <div class="inline-block rounded border border-gray-600 bg-gray-900 p-2">
                            <canvas id="singlePreviewCanvas" class="block"></canvas>
                        </div>
                    </div>

                    <div>
                        <label class="block text-xs uppercase text-gray-500">Output Name</label>
                        <input type="text" id="singleOutputName" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 focus:outline-none focus:border-blue-500">
                    </div>

                    <div>
                        <label class="block text-xs uppercase text-gray-500">Single Export Scale</label>
                        <div class="flex items-center justify-between">
                            <span class="text-xs uppercase text-gray-500"> </span>
                            <span id="singleExportScaleValue" class="text-xs text-gray-400">1</span>
                        </div>
                        <input type="range" id="singleExportScale" value="1" min="1" max="10" step="1" class="w-full accent-blue-500">
                        <p class="text-[10px] text-gray-500 mt-1">Applies to single-icon exports only.</p>
                    </div>

                    <div class="pt-1">
                        <label class="block text-xs uppercase text-gray-500">Solid Icon Color</label>
                        <input type="color" id="solidIconColor" value="#ffffff" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 h-9 focus:outline-none focus:border-blue-500">
                        <label class="flex items-center gap-2 text-xs text-gray-400 mt-1 select-none">
                            <input type="checkbox" id="applySolidIconColor" class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-blue-600 focus:ring-blue-500">
                            <span>Apply</span>
                        </label>
                        <p class="text-[10px] text-gray-500 mt-1">Applies only when an icon’s non-transparent pixels are all the same color.</p>
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="exportSinglePng" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded transition disabled:opacity-50 disabled:cursor-not-allowed">PNG</button>
                        <button id="exportSingleSvg" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-3 rounded transition disabled:opacity-50 disabled:cursor-not-allowed">SVG</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const fileInput = document.getElementById('fileInput');
        
        const srcCanvas = document.getElementById('srcCanvas');
        const srcCtx = srcCanvas.getContext('2d', { willReadFrequently: true });
        
        const overlayCanvas = document.getElementById('overlayCanvas');
        const overlayCtx = overlayCanvas.getContext('2d');

        const processBtn = document.getElementById('processBtn');

        const showOverlayInput = document.getElementById('showOverlay');

        const singleExportPanel = document.getElementById('singleExportPanel');
        const singleOutputName = document.getElementById('singleOutputName');
        const singleExportScale = document.getElementById('singleExportScale');
        const exportSinglePngBtn = document.getElementById('exportSinglePng');
        const exportSingleSvgBtn = document.getElementById('exportSingleSvg');

        const singlePreviewCanvas = document.getElementById('singlePreviewCanvas');
        const singlePreviewCtx = singlePreviewCanvas.getContext('2d');
        const SINGLE_PREVIEW_SCALE = 16;
        
        // Inputs
        const inputs = {
            offsetX: document.getElementById('offsetX'),
            offsetY: document.getElementById('offsetY'),
            iconWidth: document.getElementById('iconWidth'),
            iconHeight: document.getElementById('iconHeight'),
            gapX: document.getElementById('gapX'),
            gapY: document.getElementById('gapY'),
            groupCount: document.getElementById('groupCount'),
            groupNames: document.getElementById('groupNames'),
            groupOffsetX: document.getElementById('groupOffsetX'),
            colsPerGroup: document.getElementById('colsPerGroup'),
            exportScale: document.getElementById('exportScale'),
            applySolidIconColor: document.getElementById('applySolidIconColor'),
            solidIconColor: document.getElementById('solidIconColor'),
            previewZoom: document.getElementById('previewZoom'),
        };

        const sliderValueLabels = {
            exportScale: document.getElementById('exportScaleValue'),
            previewZoom: document.getElementById('previewZoomValue'),
            singleExportScale: document.getElementById('singleExportScaleValue'),
        };

        let img = new Image();
        let isImageLoaded = false;

        let showOverlay = true;

        /** @type {{g:number,row:number,col:number,x:number,y:number,w:number,h:number,indexInGroup:number,groupLabel:string}[]} */
        let detectedIcons = [];
        /** @type {null|{g:number,row:number,col:number,x:number,y:number,w:number,h:number,indexInGroup:number,groupLabel:string}} */
        let selectedIcon = null;
        /** @type {null|{g:number,row:number,col:number,x:number,y:number,w:number,h:number,indexInGroup:number,groupLabel:string}} */
        let hoveredIcon = null;

        /** @type {Map<string, {g:number,row:number,col:number,x:number,y:number,w:number,h:number,indexInGroup:number,groupLabel:string}>} */
        let iconByKey = new Map();
        /** @type {Map<number, Map<number, number[]>>} */
        let groupRowCols = new Map();

        // Event Listeners
        fileInput.addEventListener('change', handleFileSelect);
        Object.values(inputs).forEach(input => input.addEventListener('input', drawPreview));
        if (inputs.exportScale) inputs.exportScale.addEventListener('input', updateSliderValueLabels);
        if (inputs.previewZoom) inputs.previewZoom.addEventListener('input', updateSliderValueLabels);
        if (singleExportScale) singleExportScale.addEventListener('input', updateSliderValueLabels);
        processBtn.addEventListener('click', processAndDownload);
        window.addEventListener('resize', drawPreview);
        window.addEventListener('keydown', handleKeyDown);
        overlayCanvas.addEventListener('click', handleCanvasClick);
        overlayCanvas.addEventListener('mousemove', handleCanvasHover);
        overlayCanvas.addEventListener('mouseleave', handleCanvasLeave);
        exportSinglePngBtn.addEventListener('click', () => exportSelectedSingle('png'));
        exportSingleSvgBtn.addEventListener('click', () => exportSelectedSingle('svg'));
        showOverlayInput.addEventListener('change', handleOverlayToggle);
        if (inputs.applySolidIconColor) inputs.applySolidIconColor.addEventListener('change', handleApplySolidIconColorToggle);

        handleOverlayToggle();
        handleApplySolidIconColorToggle();
        updateSliderValueLabels();

        function updateSliderValueLabels() {
            if (sliderValueLabels.exportScale && inputs.exportScale) {
                sliderValueLabels.exportScale.textContent = String(inputs.exportScale.value);
            }
            if (sliderValueLabels.previewZoom && inputs.previewZoom) {
                sliderValueLabels.previewZoom.textContent = String(inputs.previewZoom.value);
            }
            if (sliderValueLabels.singleExportScale && singleExportScale) {
                sliderValueLabels.singleExportScale.textContent = String(singleExportScale.value);
            }
        }

        function handleOverlayToggle() {
            showOverlay = !!showOverlayInput.checked;
            overlayCanvas.style.opacity = '1';
            drawPreview();
        }

        function handleApplySolidIconColorToggle() {
            if (!inputs.applySolidIconColor || !inputs.solidIconColor) return;
            const enabled = !!inputs.applySolidIconColor.checked;
            inputs.solidIconColor.disabled = !enabled;
            inputs.solidIconColor.classList.toggle('opacity-50', !enabled);
            drawPreview();
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                img = new Image();
                img.onload = function() {
                    isImageLoaded = true;
                    processBtn.removeAttribute('disabled');
                    drawPreview();
                    setSelectedIcon(null);
                }
                img.src = event.target.result;
            }
            reader.readAsDataURL(file);
        }

        function isTypingIntoField() {
            const el = document.activeElement;
            if (!el) return false;
            const tag = (el.tagName || "").toLowerCase();
            if (tag === 'input' || tag === 'textarea' || tag === 'select') return true;
            if (el.isContentEditable) return true;
            return false;
        }

        function keyForIcon(icon) {
            return `${icon.g}:${icon.row}:${icon.col}`;
        }

        function sameIcon(a, b) {
            if (!a || !b) return false;
            return a.g === b.g && a.row === b.row && a.col === b.col;
        }

        function buildIconIndexes() {
            iconByKey = new Map();
            groupRowCols = new Map();

            for (const ic of detectedIcons) {
                iconByKey.set(keyForIcon(ic), ic);

                if (!groupRowCols.has(ic.g)) groupRowCols.set(ic.g, new Map());
                const rowMap = groupRowCols.get(ic.g);
                if (!rowMap.has(ic.row)) rowMap.set(ic.row, []);
                rowMap.get(ic.row).push(ic.col);
            }

            for (const rowMap of groupRowCols.values()) {
                for (const [row, cols] of rowMap.entries()) {
                    cols.sort((a, b) => a - b);
                    rowMap.set(row, cols);
                }
            }
        }

        function findClosestColInRow(rowCols, desiredCol) {
            if (!rowCols || rowCols.length === 0) return null;

            let best = rowCols[0];
            let bestDist = Math.abs(best - desiredCol);
            for (const c of rowCols) {
                const d = Math.abs(c - desiredCol);
                if (d < bestDist) {
                    bestDist = d;
                    best = c;
                }
            }
            return best;
        }

        function navigateSelection(direction) {
            if (!isImageLoaded || !selectedIcon) return false;
            const g = selectedIcon.g;
            const rowMap = groupRowCols.get(g);
            if (!rowMap) return false;

            const currentRow = selectedIcon.row;
            const currentCol = selectedIcon.col;

            if (direction === 'left' || direction === 'right') {
                const cols = rowMap.get(currentRow) || [];
                if (cols.length === 0) return false;

                if (direction === 'left') {
                    for (let i = cols.length - 1; i >= 0; i--) {
                        if (cols[i] < currentCol) {
                            const hit = iconByKey.get(`${g}:${currentRow}:${cols[i]}`);
                            if (hit) { setSelectedIcon(hit); drawPreview(); return true; }
                        }
                    }

                    const rows = Array.from(rowMap.keys()).sort((a, b) => a - b);
                    for (let i = rows.length - 1; i >= 0; i--) {
                        const r = rows[i];
                        if (r >= currentRow) continue;
                        const rCols = rowMap.get(r) || [];
                        if (rCols.length === 0) continue;
                        const hit = iconByKey.get(`${g}:${r}:${rCols[rCols.length - 1]}`);
                        if (hit) { setSelectedIcon(hit); drawPreview(); return true; }
                    }
                    return false;
                }

                for (let i = 0; i < cols.length; i++) {
                    if (cols[i] > currentCol) {
                        const hit = iconByKey.get(`${g}:${currentRow}:${cols[i]}`);
                        if (hit) { setSelectedIcon(hit); drawPreview(); return true; }
                    }
                }

                const rows = Array.from(rowMap.keys()).sort((a, b) => a - b);
                for (let i = 0; i < rows.length; i++) {
                    const r = rows[i];
                    if (r <= currentRow) continue;
                    const rCols = rowMap.get(r) || [];
                    if (rCols.length === 0) continue;
                    const hit = iconByKey.get(`${g}:${r}:${rCols[0]}`);
                    if (hit) { setSelectedIcon(hit); drawPreview(); return true; }
                }
                return false;
            }

            if (direction === 'up' || direction === 'down') {
                const rows = Array.from(rowMap.keys()).sort((a, b) => a - b);
                if (rows.length === 0) return false;

                if (direction === 'up') {
                    for (let i = rows.length - 1; i >= 0; i--) {
                        const r = rows[i];
                        if (r >= currentRow) continue;
                        const rCols = rowMap.get(r) || [];
                        const bestCol = findClosestColInRow(rCols, currentCol);
                        if (bestCol === null) continue;
                        const hit = iconByKey.get(`${g}:${r}:${bestCol}`);
                        if (hit) { setSelectedIcon(hit); drawPreview(); return true; }
                    }
                    return false;
                }

                for (let i = 0; i < rows.length; i++) {
                    const r = rows[i];
                    if (r <= currentRow) continue;
                    const rCols = rowMap.get(r) || [];
                    const bestCol = findClosestColInRow(rCols, currentCol);
                    if (bestCol === null) continue;
                    const hit = iconByKey.get(`${g}:${r}:${bestCol}`);
                    if (hit) { setSelectedIcon(hit); drawPreview(); return true; }
                }
                return false;
            }

            return false;
        }

        function handleKeyDown(e) {
            if (!isImageLoaded) return;
            if (isTypingIntoField()) return;

            const key = e.key;
            let dir = null;
            if (key === 'ArrowLeft') dir = 'left';
            else if (key === 'ArrowRight') dir = 'right';
            else if (key === 'ArrowUp') dir = 'up';
            else if (key === 'ArrowDown') dir = 'down';
            if (!dir) return;
            if (!selectedIcon) return;

            const moved = navigateSelection(dir);
            if (moved) {
                e.preventDefault();
            }
        }

        function getSettings() {
            return {
                xOrig: parseInt(inputs.offsetX.value) || 12,
                yOrig: parseInt(inputs.offsetY.value) || 34,
                w: parseInt(inputs.iconWidth.value) || 9,
                h: parseInt(inputs.iconHeight.value) || 9,
                gapX: parseInt(inputs.gapX.value) || 2,
                gapY: parseInt(inputs.gapY.value) || 2,
                groups: parseInt(inputs.groupCount.value) || 7,
                groupNames: parseGroupNames(inputs.groupNames.value || "people, nature, food, activity, travel, objects, symbols"),
                groupOffX: parseInt(inputs.groupOffsetX.value) || 99,
                cols: parseInt(inputs.colsPerGroup.value) || 8,
                scale: parseInt(inputs.exportScale.value) || 1,
                applySolidIconColor: (inputs.applySolidIconColor ? !!inputs.applySolidIconColor.checked : true),
                solidIconColor: (inputs.solidIconColor && inputs.solidIconColor.value) ? String(inputs.solidIconColor.value) : "#ffffff",
                previewZoom: Math.max(1, parseFloat(inputs.previewZoom.value) || 3),
            };
        }

        function hexToRgb(hex) {
            const raw = String(hex || "").trim();
            const m = raw.match(/^#?([0-9a-f]{3}|[0-9a-f]{6})$/i);
            if (!m) return null;
            let h = m[1];
            if (h.length === 3) h = h.split('').map(ch => ch + ch).join('');
            const n = parseInt(h, 16);
            return {
                r: (n >> 16) & 255,
                g: (n >> 8) & 255,
                b: n & 255,
            };
        }

        function isIconSolidColor(imageData) {
            const d = imageData.data;
            let first = null;
            for (let i = 0; i < d.length; i += 4) {
                const a = d[i + 3];
                if (a === 0) continue;
                const r = d[i], g = d[i + 1], b = d[i + 2];
                if (!first) {
                    first = { r, g, b };
                    continue;
                }
                if (r !== first.r || g !== first.g || b !== first.b) return false;
            }

            return !!first;
        }

        function applySolidColorOverrideIfNeeded(imageData, s) {
            if (!imageData || !imageData.data || !s) return imageData;
            if (s.applySolidIconColor === false) return imageData;
            if (!isIconSolidColor(imageData)) return imageData;

            const rgb = hexToRgb(s.solidIconColor);
            if (!rgb) return imageData;

            const d = imageData.data;
            for (let i = 0; i < d.length; i += 4) {
                const a = d[i + 3];
                if (a === 0) continue;
                d[i] = rgb.r;
                d[i + 1] = rgb.g;
                d[i + 2] = rgb.b;
            }
            return imageData;
        }

        function applyPreviewZoom(zoom) {
            if (!isImageLoaded) return;
            const z = Math.max(1, Number(zoom) || 1.5);
            const cssW = Math.max(1, Math.round(img.width * z));
            const cssH = Math.max(1, Math.round(img.height * z));

            srcCanvas.style.width = `${cssW}px`;
            srcCanvas.style.height = `${cssH}px`;
            overlayCanvas.style.width = `${cssW}px`;
            overlayCanvas.style.height = `${cssH}px`;
        }

        function getCanvasPointFromMouseEvent(canvas, e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY,
            };
        }

        function parseGroupNames(raw) {
            return raw
                .split(',')
                .map(s => s.trim())
                .filter(Boolean);
        }

        function sanitizeFilePart(name) {
            return String(name)
                .replace(/[\\/:*?"<>|]+/g, "_")
                .replace(/\s+/g, " ")
                .trim();
        }

        function getGroupLabel(s, gIndex) {
            const raw = (s.groupNames && s.groupNames[gIndex]) ? s.groupNames[gIndex] : `group${gIndex + 1}`;
            const safe = sanitizeFilePart(raw);
            return safe || `group${gIndex + 1}`;
        }

        function padIndex(n) {
            return String(n).padStart(3, '0');
        }

        function makeDefaultIconName(icon) {
            if (icon && typeof icon.indexInGroup === 'number' && icon.indexInGroup > 0) {
                return `${icon.groupLabel}_${padIndex(icon.indexInGroup)}`;
            }
            return `${icon.groupLabel}_row${icon.row + 1}_col${icon.col + 1}`;
        }

        function isBlockBlack(x, y, w, h) {
            // Get pixel data
            try {
                const p = srcCtx.getImageData(x, y, w, h).data;
                for (let i = 0; i < p.length; i += 4) {
                    const r = p[i];
                    const g = p[i+1];
                    const b = p[i+2];
                    const a = p[i+3];

                    if (r !== 0 || g !== 0 || b !== 0 || a !== 255) {
                        return false; 
                    }
                }
                return true;
            } catch (e) {
                return false;
            }
        }

        function drawPreview() {
            if (!isImageLoaded) return;

            const s = getSettings();

            updateSliderValueLabels();

            detectedIcons = [];
            
            if (srcCanvas.width !== img.width || srcCanvas.height !== img.height) {
                srcCanvas.width = img.width;
                srcCanvas.height = img.height;
                overlayCanvas.width = img.width;
                overlayCanvas.height = img.height;
            }

            srcCtx.drawImage(img, 0, 0);

            applyPreviewZoom(s.previewZoom);

            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

            overlayCtx.strokeStyle = 'rgba(255, 0, 255, 0.8)';
            overlayCtx.fillStyle = 'rgba(255, 0, 255, 0.2)';
            overlayCtx.lineWidth = 1;

            for (let g = 0; g < s.groups; g++) {
                const groupStartX = s.xOrig + (g * s.groupOffX);
                const groupLabel = getGroupLabel(s, g);
                let indexInGroup = 0;
                
                let row = 0;
                let activeGroup = true;
                
                while (activeGroup) {
                    if (row > 5000) break; 
                    
                    const rowY = s.yOrig + row * (s.h + s.gapY);
                    if (rowY + s.h > overlayCanvas.height) break;

                    for (let col = 0; col < s.cols; col++) {
                        const colX = groupStartX + col * (s.w + s.gapX);
                        if (colX + s.w > overlayCanvas.width) break;

                        const isBlack = isBlockBlack(colX, rowY, s.w, s.h);
                        
                        if (isBlack) {
                            if (col === 0) {
                                activeGroup = false;
                                break;
                            } else {
                                break;
                            }
                        }

                        indexInGroup++;
                        const icon = { g, row, col, x: colX, y: rowY, w: s.w, h: s.h, indexInGroup, groupLabel };
                        detectedIcons.push(icon);

                        if (showOverlay) {
                            overlayCtx.strokeRect(colX, rowY, s.w, s.h);
                            overlayCtx.fillRect(colX, rowY, s.w, s.h);
                        }
                    }

                    if (!activeGroup) break;
                    
                    row++;
                }
            }

            buildIconIndexes();

            if (hoveredIcon) {
                const stillThereHover = detectedIcons.find(ic => ic.g === hoveredIcon.g && ic.row === hoveredIcon.row && ic.col === hoveredIcon.col);
                hoveredIcon = stillThereHover || null;
            }

            if (hoveredIcon && !sameIcon(hoveredIcon, selectedIcon)) {
                overlayCtx.save();
                overlayCtx.strokeStyle = 'rgba(255, 0, 255, 0.95)';
                overlayCtx.lineWidth = 2;
                overlayCtx.strokeRect(hoveredIcon.x + 0.5, hoveredIcon.y + 0.5, hoveredIcon.w - 1, hoveredIcon.h - 1);
                overlayCtx.restore();
            }

            if (selectedIcon) {
                const stillThere = detectedIcons.find(ic => ic.g === selectedIcon.g && ic.row === selectedIcon.row && ic.col === selectedIcon.col);
                if (!stillThere) {
                    setSelectedIcon(null);
                } else {
                    selectedIcon = stillThere;
                    overlayCtx.save();
                    overlayCtx.strokeStyle = 'rgba(0, 255, 255, 0.95)';
                    overlayCtx.lineWidth = 2;
                    overlayCtx.strokeRect(selectedIcon.x + 0.5, selectedIcon.y + 0.5, selectedIcon.w - 1, selectedIcon.h - 1);
                    overlayCtx.restore();
                }
            }

            updateSinglePreview();
        }

        function setSelectedIcon(icon) {
            selectedIcon = icon;

            const disabled = !selectedIcon;
            exportSinglePngBtn.disabled = disabled;
            exportSingleSvgBtn.disabled = disabled;
            singleOutputName.disabled = disabled;
            if (singleExportScale) singleExportScale.disabled = disabled;

            if (!selectedIcon) {
                singleOutputName.value = "";
                updateSinglePreview();
                updateSliderValueLabels();
                return;
            }

            singleExportPanel.style.display = "block";

            const idxLabel = (typeof selectedIcon.indexInGroup === 'number' && selectedIcon.indexInGroup > 0)
                ? `#${padIndex(selectedIcon.indexInGroup)}`
                : `row ${selectedIcon.row + 1} • col ${selectedIcon.col + 1}`;

            singleOutputName.value = makeDefaultIconName(selectedIcon);
            updateSinglePreview();
            updateSliderValueLabels();
        }

        function handleCanvasClick(e) {
            if (!isImageLoaded || detectedIcons.length === 0) return;

            const { x, y } = getCanvasPointFromMouseEvent(overlayCanvas, e);

            const hit = detectedIcons.find(ic => x >= ic.x && x < ic.x + ic.w && y >= ic.y && y < ic.y + ic.h);
            if (!hit) {
                setSelectedIcon(null);
                singleExportPanel.style.display = "none";
                drawPreview();
                return;
            }

            setSelectedIcon(hit);
            drawPreview();
        }

        function handleCanvasHover(e) {
            if (!isImageLoaded || detectedIcons.length === 0) return;
            const { x, y } = getCanvasPointFromMouseEvent(overlayCanvas, e);
            const hit = detectedIcons.find(ic => x >= ic.x && x < ic.x + ic.w && y >= ic.y && y < ic.y + ic.h) || null;
            if (sameIcon(hit, hoveredIcon)) return;
            hoveredIcon = hit;
            drawPreview();
        }

        function handleCanvasLeave() {
            if (!hoveredIcon) return;
            hoveredIcon = null;
            drawPreview();
        }

        function extractIconImageDataWithScale(icon, scaleOverride) {
            const s = getSettings();
            const imageData = srcCtx.getImageData(icon.x, icon.y, s.w, s.h);

            for (let i = 0; i < imageData.data.length; i += 4) {
                const r = imageData.data[i];
                const g = imageData.data[i + 1];
                const b = imageData.data[i + 2];
                if (r === 0 && g === 0 && b === 0) {
                    imageData.data[i + 3] = 0;
                }
            }

            applySolidColorOverrideIfNeeded(imageData, s);
            return { imageData, w: s.w, h: s.h, scale: scaleOverride ?? s.scale };
        }

        function extractIconImageData(icon) {
            return extractIconImageDataWithScale(icon, undefined);
        }

        function updateSinglePreview() {
            if (!singlePreviewCanvas || !singlePreviewCtx) return;

            if (!isImageLoaded || !selectedIcon) {
                singlePreviewCanvas.width = 1;
                singlePreviewCanvas.height = 1;
                singlePreviewCtx.clearRect(0, 0, 1, 1);
                return;
            }

            const { imageData, w, h } = extractIconImageDataWithScale(selectedIcon, SINGLE_PREVIEW_SCALE);

            singlePreviewCanvas.width = w * SINGLE_PREVIEW_SCALE;
            singlePreviewCanvas.height = h * SINGLE_PREVIEW_SCALE;
            singlePreviewCtx.imageSmoothingEnabled = false;
            singlePreviewCtx.clearRect(0, 0, singlePreviewCanvas.width, singlePreviewCanvas.height);

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w;
            tempCanvas.height = h;
            tempCanvas.getContext('2d').putImageData(imageData, 0, 0);

            singlePreviewCtx.drawImage(
                tempCanvas,
                0, 0, w, h,
                0, 0, w * SINGLE_PREVIEW_SCALE, h * SINGLE_PREVIEW_SCALE
            );
        }

        function exportSelectedSingle(kind) {
            if (!selectedIcon) return;

            const raw = singleExportScale ? parseInt(singleExportScale.value, 10) : NaN;
            const chosenScale = Math.max(1, Math.min(10, Number.isFinite(raw) ? raw : 1));

            const { imageData, w, h, scale } = extractIconImageDataWithScale(selectedIcon, chosenScale);
            const baseNameRaw = (singleOutputName.value || makeDefaultIconName(selectedIcon)).trim();
            const baseName = sanitizeFilePart(baseNameRaw) || makeDefaultIconName(selectedIcon);

            if (kind === 'png') {
                const hiddenCanvas = document.createElement('canvas');
                hiddenCanvas.width = w * scale;
                hiddenCanvas.height = h * scale;
                const hCtx = hiddenCanvas.getContext('2d');
                hCtx.imageSmoothingEnabled = false;

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = w;
                tempCanvas.height = h;
                tempCanvas.getContext('2d').putImageData(imageData, 0, 0);

                hCtx.drawImage(tempCanvas, 0, 0, w, h, 0, 0, w * scale, h * scale);
                hiddenCanvas.toBlob((blob) => {
                    if (!blob) return;
                    saveAs(blob, `${baseName}.png`);
                }, 'image/png');
                return;
            }

            if (kind === 'svg') {
                const svgContent = generateSvg(imageData, w, h, scale);
                const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
                saveAs(blob, `${baseName}.svg`);
            }
        }

        async function processAndDownload() {
            if (!isImageLoaded) return;
            processBtn.disabled = true;
            
            const zip = new JSZip();
            const s = getSettings();
            const sFolder = zip.folder("svg");
            const pFolder = zip.folder("png");

            for (let g = 0; g < s.groups; g++) {
                const groupStartX = s.xOrig + (g * s.groupOffX);
                const groupLabel = getGroupLabel(s, g);
                let indexInGroup = 0;
                let row = 0;
                let activeGroup = true;

                while (activeGroup) {
                    if (row > 5000) break; // Safety
                    const rowY = s.yOrig + row * (s.h + s.gapY);
                    if (rowY + s.h > img.height) break;

                    for (let col = 0; col < s.cols; col++) {
                        const colX = groupStartX + col * (s.w + s.gapX);
                        if (colX + s.w > img.width) break;

                        const isBlack = isBlockBlack(colX, rowY, s.w, s.h);
                        if (isBlack) {
                            if (col === 0) { activeGroup = false; break; } 
                            else { break; }
                        }

                        indexInGroup++;

                        const imageData = srcCtx.getImageData(colX, rowY, s.w, s.h);
                        
                        for (let i = 0; i < imageData.data.length; i += 4) {
                            if (imageData.data[i] === 0 && imageData.data[i+1] === 0 && imageData.data[i+2] === 0) {
                                imageData.data[i+3] = 0;
                            }
                        }

                        applySolidColorOverrideIfNeeded(imageData, s);

                        const fileName = `${groupLabel}_${padIndex(indexInGroup)}`;

                        const hiddenCanvas = document.createElement('canvas');
                        hiddenCanvas.width = s.w * s.scale;
                        hiddenCanvas.height = s.h * s.scale;
                        const hCtx = hiddenCanvas.getContext('2d');
                        hCtx.imageSmoothingEnabled = false;

                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = s.w;
                        tempCanvas.height = s.h;
                        tempCanvas.getContext('2d').putImageData(imageData, 0, 0);

                        hCtx.drawImage(tempCanvas, 0, 0, s.w, s.h, 0, 0, s.w * s.scale, s.h * s.scale);
                        
                        const pngData = hiddenCanvas.toDataURL("image/png").split(',')[1];
                        pFolder.file(`${fileName}.png`, pngData, {base64: true});

                        const svgContent = generateSvg(imageData, s.w, s.h, s.scale);
                        sFolder.file(`${fileName}.svg`, svgContent);
                    }
                    if (!activeGroup) break;
                    row++;
                }
            }

            const content = await zip.generateAsync({type:"blob"});
            saveAs(content, "emojimania_icons.zip");
            
            processBtn.disabled = false;
        }

        function generateSvg(imageData, w, h, scale) {
            let rects = "";
            const data = imageData.data;
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const r = data[i];
                    const g = data[i+1];
                    const b = data[i+2];
                    const a = data[i+3];
                    
                    if (a > 0) {
                        const hex = rgbToHex(r, g, b);
                        const opacity = a < 255 ? ` fill-opacity="${(a/255).toFixed(2)}"` : "";
                        rects += `<rect x="${x}" y="${y}" width="1" height="1" fill="${hex}"${opacity}/>`;
                    }
                }
            }
            const finalW = w * scale || w;
            const finalH = h * scale || h;
            return `<svg xmlns="http://www.w3.org/2000/svg" width="${finalW}" height="${finalH}" viewBox="0 0 ${w} ${h}">${rects}</svg>`;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
    </script>
</body>
</html>
